# 代码随想录刷题

## 数组

### 二分查找

**使用二分查找的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。

对于区间定义即不变量要清晰，例如到底是 `while(left < right)` 还是 `while(left <= right)`，到底是`right = middle`呢，还是要`right = middle - 1`呢？

常用

![704.二分查找](./代码随想录刷题.assets/20210311153055723.jpg)

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```

### 移除元素

最常用双指针即快慢指针法

![27.移除元素-双指针法](./代码随想录刷题.assets/27.移除元素-双指针法.gif)

```c++
// 时间复杂度：O(n)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];		//此处slowIndex后自加
            }
        }
        return slowIndex;
    }
};
```

### 有序数组的平方

#### 双指针法

数组其实是有序的， 只不过负数平方之后可能成为最大数了。

那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

此时可以考虑双指针法了，i指向起始位置，j指向终止位置。

定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

如果`A[i] * A[i] < A[j] * A[j]` 那么`result[k--] = A[j] * A[j];` 。

如果`A[i] * A[i] >= A[j] * A[j]` 那么`result[k--] = A[i] * A[i];` 。

如动画所示：

![img](./代码随想录刷题.assets/977.有序数组的平方.gif)

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        int k = A.size() - 1;
        vector<int> result(A.size(), 0);
        for (int i = 0, j = A.size() - 1; i <= j;) { // 注意这里要i <= j，因为最后要处理两个元素
            if (A[i] * A[i] < A[j] * A[j])  {
                result[k--] = A[j] * A[j];
                j--;
            }
            else {
                result[k--] = A[i] * A[i];
                i++;
            }
        }
        return result;
    }
};
```

### 长度最小的子数组

使用滑动窗口的方式

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置**，代码里面关于保存子窗口长度的+1很关键，植树问题。

![209.长度最小的子数组](./代码随想录刷题.assets/209.长度最小的子数组.gif)

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int sum = 0;    //子窗口数据之和
        int result = INT32_MAX; //返回结果，默认为int的最大值
        int length = 0;  //子窗口长度
        int i = 0 ; //子窗口左边的位置

        for (int j = 0; j < nums.size(); j++){
            sum += nums[j];     //将子窗口右边的位置的值保存在sum中

            while (sum >= target){
                length = j - i + 1; //保存子窗口的长度
                result = (result < length ? result : length);   //判断是不是最小的窗口

                sum -= nums[i];     //减去最左边位置的值
                i++;                //左边位置移位
            }
        }

        if(result == INT32_MAX) 
            return 0;
        else
            return result;
    }
};
```

[904. 水果成篮 - 力扣（LeetCode）](https://leetcode.cn/problems/fruit-into-baskets/description/)

### 螺旋矩阵

[59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n,vector(n,0)); //使用vector定义一个二维数组
        int startx,starty; //每次开始的下标
        int i,j;    //用于循环
        int loop = n/2; //循环圈数
        int mid = n/2;  //中心点
        int count = 1; //用于给方格赋值
        int offset = 1; //控制每一条遍历的长度，每次循环到右边界收缩一格

        while(loop--)
        {
            i = startx;
            j = starty;

            // 下面开始模拟转一圈
            // 模拟填充上行从左到右(左闭右开)   i不变，j增加    需要考虑右边界收缩
            for(j = starty;j < n - offset;j++){
                res[i][j] = count++; 
            }

             // 模拟填充右列从上到下(左闭右开)  j不变，i增加    需要考虑右边界收缩
             for(i = startx;i < n - offset;i++){
                res[i][j] = count++;
             }

             // 模拟填充下行从右到左(左闭右开)  i不变，j减小
             for(;j > starty;j--){
                res[i][j] = count++;
             }

             // 模拟填充左列从下到上(左闭右开)  j不变，i减小
             for(;i > startx;i--){
                res[i][j] = count++;
             }

             //下一轮起始位置各加一
             startx++;
             starty++;

             //改变offset
             offset++;             
        }

        //奇数行需要单独填写最中间的值
        if(n % 2)
        {
            res[mid][mid] = count;
        }

        return res;
    }
};
```



## 链表

### 移除链表元素

[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)

虚拟头节点的方法更加容易理解

![203_链表删除元素6](https://code-thinking-1253855093.file.myqcloud.com/pics/20210316095619221.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode *fakehead = new ListNode(0);		//创建一个虚拟头节点
        fakehead->next = head;						//虚拟头节点的下一个指向head
        ListNode *cur = fakehead;					//使用cur作为当前节点

        while(cur->next != NULL)					//遍历，如果没有到链表尾部
        {
            if(cur->next->val == val)				//是要删除的值
            {
                ListNode *tmp = cur->next;			//使用中间变量保存要删除的节点
                cur->next = cur->next->next;		//节点下一个指向下一个的下一个
                delete tmp;							//释放要删除节点的内存
            }
            else
                cur = cur->next;					//移动cur
        }

        head = fakehead->next;						//返回虚拟节点的下一个
        delete fakehead;							//释放虚拟节点的内存
        return head;								//返回
    }
};
```

### 设计链表

[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/)

![链表-删除节点](./代码随想录刷题.assets/20200806195114541.png)

![链表-添加节点](./代码随想录刷题.assets/20200806195134331.png)

```c++
class MyLinkedList {
public:
    struct ListNode{
        int val;                //值
        ListNode *Next;         //地址
        ListNode(int val):val(val),Next(nullptr){}      //构造函数初始化列表
    };

    MyLinkedList() {
        fakehead = new ListNode(0);
        size = 0;
    }
    
    int get(int index) {
        if(index > size - 1 || index < 0)   //输入参数有误
            return -1;
        
        ListNode *cur = fakehead->Next;

        while(index--)
        {
            cur = cur->Next;
        }

        return cur->val;
    }
    
    void addAtHead(int val) {
        ListNode *newNode = new ListNode(val);      //创建一个新节点同时赋值
        newNode->Next = fakehead->Next;             //将新节点挂到原链表的前面
        fakehead->Next = newNode;                   //将虚拟节点放到新节点前
        size++;                                     //链表长度加一
    }
    
    void addAtTail(int val) {
        ListNode *newNode = new ListNode(val);      //创建一个新节点同时赋值
        ListNode *cur = fakehead;

        while(cur->Next != NULL)                     //寻找链表尾
        {
            cur = cur->Next;
        }

        cur->Next = newNode;                         //新节点放在链表后
        size++;
    }
    
    void addAtIndex(int index, int val) {
        if(index > size) return;
        if(index < 0) index = 0;

        ListNode *newNode = new ListNode(val);       //创建一个新节点同时赋值
        ListNode *cur = fakehead;

        while(index--)
        {
            cur = cur->Next;
        }

        newNode->Next = cur->Next;                    //新节点的下一个为原链表的下一个
        cur->Next = newNode;                          //当前节点的下一个为新节点
        size++;
    }
    
    void deleteAtIndex(int index) {
        if(index >= size || index < 0)  return;       //index大于size或者小于0返回

        ListNode *newNode = new ListNode(0);          //创建一个新节点同时赋值
        ListNode *cur = fakehead;        

        while(index--)
        {
            cur = cur->Next;
        }

        ListNode *tmp = cur->Next;
        cur->Next = cur->Next->Next;

        delete tmp;                                   //释放tmp
        tmp = NULL;                                   //防止tmp变成野指针
        size--;
    }
private:
    ListNode *fakehead;
    int size;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

### 反转链表

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)

#### 双指针法

最重要的思想就是用tmp保存cur->next，保证原链表不变动的情况下翻转。

首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。

然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。

为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。

接下来，就是循环走如下代码逻辑了，先移动pre指针，再移动cur指针。

最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = NULL;
        ListNode* cur = head;

        while(cur != nullptr)
        {
            ListNode* tmp = cur->next;  //保存中间值
            cur->next = pre;    //翻转操作
            pre = cur;          //移动pre
            cur = tmp;          //移动到下一个节点
        }

        return pre;
    }
};
```

#### 递归法

```c++
class Solution {
public:
    ListNode* reverse(ListNode* pre,ListNode* cur){
        if(cur == NULL) return pre;
        ListNode* temp = cur->next;
        cur->next = pre;
        // 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步
        // pre = cur;
        // cur = temp;
        return reverse(cur,temp);
    }
    ListNode* reverseList(ListNode* head) {
        // 和双指针法初始化是一样的逻辑
        // ListNode* cur = head;
        // ListNode* pre = NULL;
        return reverse(NULL, head);
    }

};
```

### 两两交换链表中的节点

[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

初始时，cur指向虚拟头结点，然后进行如下三步：

![24.两两交换链表中的节点1](./代码随想录刷题.assets/24.两两交换链表中的节点1-1715848877492-3.png)

看这个可能就更直观一些了：

![24.两两交换链表中的节点3](./代码随想录刷题.assets/24.两两交换链表中的节点3.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* fakenode = new ListNode(0);
        fakenode->next = head;
        ListNode* cur = fakenode;
        ListNode* tmp1;
        ListNode* tmp2;

        while(cur->next != nullptr && cur->next->next != nullptr)   //下一节点和下下节点不为空
        {
            tmp1 = cur->next;                   //暂存原节点下个节点
            tmp2 = cur->next->next->next;       //暂存原节点下下下个节点

            cur->next = cur->next->next;        //步骤一
            cur->next->next = tmp1;             //步骤二
            cur->next->next->next = tmp2;       //步骤三

            cur = cur->next->next;              //将cur移动两位，准备下一轮交换
        }

        ListNode* result = fakenode->next;
        delete fakenode;
        return result;
    }
};
```

### 删除链表的倒数第N个节点

[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

核心思想是使用快慢指针，先让fast指针移动n+1步，在同时移动快慢指针直到检测到null。此时再去删除慢指针的下一个节点。下面是我自己写的代码。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* fakenode = new ListNode(0);   //虚拟头节点
        fakenode->next = head;

        ListNode* fastcur = fakenode;       //快操作节点
        ListNode* slowcur = fakenode;       //慢操作节点

        n += 1;        //加1是因为虚拟头节点相比原来要多一个移位步骤

        while(n--)      //移动快指针
        {
            fastcur = fastcur->next;
        }

        while(fastcur != NULL)  //遍历链表，快指针没到末尾，快慢指针同时移动
        {
            fastcur = fastcur->next;
            slowcur = slowcur->next;
        }

        //用tmp保存slowcur的下一个节点，并且释放
        ListNode* tmp = slowcur->next;
        slowcur->next = slowcur->next->next;        //删除倒数位上的节点
        ListNode* result = fakenode->next;

        //内存释放
        delete tmp;
        delete fakenode;
        return result;
    }
};
```
下面是代码随想录写的例程代码

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* slow = dummyHead;
        ListNode* fast = dummyHead;
        while(n-- && fast != NULL) {
            fast = fast->next;
        }
        fast = fast->next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点
        while (fast != NULL) {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next; 
        
        // ListNode *tmp = slow->next;  C++释放内存的逻辑
        // slow->next = tmp->next;
        // delete tmp;
        
        return dummyHead->next;
    }
};
```

### 链表相交

[面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

这道题关键在于将两个链表对齐。

1. 先计算两个链表的长度
2. 将curA和curB恢复到原始状态
3. 求两个链表长度的差值
4. 让curA移动到，和curB 末尾对齐的位置（这边是curA为长链表）
5. 依次比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。

将**指针恢复到初始状态**需要在长度判断之前，不然swap(curA,curB)将无法起作用。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* curA = headA;
        ListNode* curB = headB;

        //计算A和B链表的长度
        int lenA = 0,lenB = 0;

        while(curA != NULL)
        {
            lenA++;
            curA = curA->next;

        }
        while(curB != NULL)
        {
            lenB++;
            curB = curB->next;
        }

        //将指针恢复到初始状态
        curA = headA;
        curB = headB;

        //A和B两者长度取最高，放在A变量里面
        if(lenB > lenA)
        {
            swap(lenA,lenB);
            swap(curA,curB);
        }

        //将两个链表保持长度一致
        int gap = lenA - lenB;
        while(gap--)
        {
            curA = curA->next;
        }

        while(curA != NULL)
        {
            if(curA == curB)        //如果两个节点指针相同，说明是交叉点
                return curA;

            curA = curA->next;      //两个指针一起前进
            curB = curB->next;
        }

        return NULL;
    }
};
```

### 环形链表

[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)

[把环形链表讲清楚！ 如何判断环形链表？如何找到环形链表的入口？ LeetCode：142.环形链表II_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1if4y1d7ob/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fastnode = head;      //定义一个快指针指向链表头
        ListNode *slownode = head;      //定义一个慢指针指向链表头

        while(fastnode != NULL && fastnode->next != NULL)
        {
            fastnode = fastnode->next->next;        //快指针每次运动两个节点
            slownode = slownode->next;              //慢指针每次运动一个节点

            if(fastnode == slownode)        //快慢节点相遇
            {
                ListNode *index1 = fastnode;        //定义一个指向相遇点的指针
                ListNode *index2 = head;            //定义一个指向链表头的指针

                while(index1 != index2)             //同时运动找到入环处
                {
                    index1 = index1->next;
                    index2 = index2->next;
                }

                return index1;                      //返回两个指针中的任意一个都行
            }
        }

        return NULL;
    }
};
```

## 哈希表

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

### 有效的字母异位词

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int recode[26] = {0};       //记录26个小写字母的哈希表

        //遍历S字符串
        for(int i = 0; i < s.size(); i++)
        {
            recode[s[i] - 'a']++;
        }

        //遍历t字符串
        for(int i = 0; i < t.size(); i++)
        {
            recode[t[i] - 'a']--;
        }

        // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
        for(int i = 0; i < 26; i++)
        {
            if(recode[i] != 0)
                return false;
        }

        return true;
    }
};
```

定义一个数组叫做record用来上记录字符串s里字符出现的次数。

需要把字符映射到数组也就是哈希表的索引下标上，**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**

再遍历 字符串s的时候，**只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。** 这样就将字符串s中字符出现的次数，统计出来了。

那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。

那么最后检查一下，**record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。**

最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。

时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。

#### 相关题目

[49. 字母异位词分组 - 力扣（LeetCode）](https://leetcode.cn/problems/group-anagrams/)

由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行**排序**之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>> mp;    //创建一个无序映射

        //遍历strs
        for(string& str : strs){
            string key = str;               //将str赋值给key
            sort(key.begin(),key.end());    //将key进行排序
            mp[key].emplace_back(str);      //将排序完的key作为键，str作为值放入映射中
        }

        vector<vector<string>> ans;         //创建一个二维向量用于返回
        for(auto it = mp.begin();it != mp.end();++it){
            ans.emplace_back(it->second);   //将所有值读出
        }
        return ans;
    }
};
```

### 快乐数

[202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/description/)

```c++
class Solution {
public:
    int GetNum(int n)
    {
        int sum = 0;
        while(n)
        {
            sum += (n%10) * (n%10);
            n /= 10;
        }
        return sum;
    }

    bool isHappy(int n) {
        unordered_set<int> set;
        while(1)
        {
            int sum = 0;
            sum = GetNum(n);

            if(sum == 1)
                return true;
            
            //如果在中间找到了，说明开始无限循环了，立刻返回false
            if(set.find(sum) != set.end()){
                return false;
            }else{
                set.insert(sum);	//集合中并不存在，插入集合中
            }
            n = sum;
        }
    }
};
```

代码随想录使用无序集合的方法，通过无限循环在集合中寻找是否有重复项，来判定是否为快乐数。

```c++
class Solution {
public:
    int GetNum(int n)
    {
        int sum = 0;
        while(n)
        {
            sum += (n%10) * (n%10);
            n /= 10;
        }
        return sum;
    }

    bool isHappy(int n) {
        int slow = n, fast = n;
        do{
            //慢指针动一步，快指针动两步
            slow = GetNum(slow);
            fast = GetNum(fast);
            fast = GetNum(fast);
        }while(slow != fast);   //两者不相等就继续

        return slow == 1;   //如果其中一个数是1代表是快乐数，否则不是
    }
};
```

力扣题解通过快慢指针解题，使用 “快慢指针” 思想，找出循环：“快指针” 每次走两步，“慢指针” 每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为 1 引起的循环，是的话就是快乐数，否则不是快乐数。
注意：此题不建议用集合记录每次的计算结果来判断是否进入循环，因为这个集合可能大到无法存储；另外，也不建议使用递归，同理，如果递归层次较深，会直接导致调用栈崩溃。不要因为这个题目给出的整数是 int 型而投机取巧。

### 两数之和

[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/)

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> map;

        //遍历数组
        for(int i = 0; i < nums.size();i++)
        {
            auto res = map.find(target - nums[i]);  //寻找nums[i]和target的差值
            if(res != map.end())    //说明找到差值
            {
                return {res->second,i}; //返回下标值
            }
            else
            {
                //map.insert(pair<int,int>(nums[i],i));
                map.emplace(nums[i],i); //没找到差值就把当前值和下标存入map中
            }
        }
        return {};
    }
};
```

在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。

![过程一](./代码随想录刷题.assets/20220711202638.png)

![过程二](./代码随想录刷题.assets/20230220223536.png)

- 为什么会想到用哈希表

    当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。

- 哈希表为什么用map

    我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，**需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适**。

- 本题map是用来存什么的

    map目的用来存放我们访问过的元素，因为遍历数组的时候，需要记录我们之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的（也就是相加等于target）

- map中的key和value用来存什么的

    数组中的元素作为key，有key对应的就是value，value用来存下标。map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。

### 四数相加Ⅱ

[454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/)

```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int> map;
        int count = 0;
        int target = 0;

        //遍历1和2数组
        for(int num1 : nums1){
            for(int num2 : nums2){
                map[num1 + num2]++;
            }
        }

        //遍历3和4数组，寻找map中的相反数
        for(int num3 : nums3){
            for(int num4 : nums4){
                target = -(num3 + num4);

                if(map.find(target) != map.end()){
                    count += map[target];       //找到了相反数就加上对应value
                }
            }
        }

        return count;
    }
};
```

本题解题步骤：

1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
5. 最后返回统计值 count 就可以了

### 救赎金

[383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/description/)

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};
        //add
        if (ransomNote.size() > magazine.size()) {
            return false;
        }
        for (int i = 0; i < magazine.length(); i++) {
            // 通过record数据记录 magazine里各个字符出现次数
            record[magazine[i]-'a'] ++;
        }
        for (int j = 0; j < ransomNote.length(); j++) {
            // 遍历ransomNote，在record里对应的字符个数做--操作
            record[ransomNote[j]-'a']--;
            // 如果小于零说明ransomNote里出现的字符，magazine没有
            if(record[ransomNote[j]-'a'] < 0) {
                return false;
            }
        }
        return true;
    }
};
```

这道题和有效的字母异位词很相似，差异在于最后遍历记录数组的时候，判断条件不再是不等于0，因为存在后一个字符串比前一个长的情况，所以应该是大于0，代表前一个字符串在后一个字符串中找不到对应的字母。

### 三数之和

[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;

        sort(nums.begin(),nums.end());      //从小到大排序

        for(int i = 0; i < nums.size(); i++){
            if(nums[i] > 0) return result;         //第一个数就大于0，不可能三数之和等于0

            if(i > 0 && nums[i] == nums[i-1]) continue;  //去重i

            int left = i + 1;               //左指针
            int right = nums.size() - 1;    //右指针

            while(right > left){
                if(nums[i] + nums[left] + nums[right] > 0) right--;
                else if(nums[i] + nums[left] + nums[right] < 0) left++;
                else{
                    result.push_back(vector<int>{nums[i],nums[left],nums[right]});

                    while(right > left && nums[left] == nums[left + 1]) left++;
                    while(right > left && nums[right] == nums[right - 1]) right--;

                    right--;
                    left++;
                }
            }
        }

        return result;
    }
};
```



![15.三数之和](https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif)

解题思路：

1. 将数组从小到大排序，检查第一个元素是否大于0，如果第一个元素都已经大于0，说明数组内不可能有满足条件的三元组
2. 用下标i遍历数组，对i进行去重，注意使用当前值和上一个值比较，这里需要当心下标i需要大于0，不然会导致数组越界
3. 选取left和right指针，分别为i+1和最大长度减一
4. 当right大于left一直循环，判断三元组的值是否等于0。大于0则移动右指针，小于则移动左指针。
5. 直到找到满足要求的三元组，此时将三元组放入返回容器中。接下来就是进行去重操作。左指针和后一个比较，右指针和前一个比较。如果相同就继续移动
6. 最后返还结果容器

### 四数之和

[18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/description/)

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;     //保存结果

        sort(nums.begin(),nums.end());  //排列一下

        for(int k = 0; k < nums.size(); k++){
            if(nums[k] > target && nums[k] >= 0) //如果第一个元素大于target说明没有符合
                break;
            
            if(k > 0 && nums[k] == nums[k - 1]) //去重
                continue;

            for(int i = k + 1; i < nums.size();i++){
                if(nums[k] + nums[i] > target && nums[k] + nums[i] >= 0)
                    break;

                if(i > k + 1 && nums[i] == nums[i - 1]) //去重
                    continue;

                //双指针
                int left = i + 1;
                int right = nums.size() - 1;

                while(right > left){
                    if((long)nums[k] + nums[i] + nums[left] + nums[right] > target) right--;
                    else if((long)nums[k] + nums[i] + nums[left] + nums[right] < target) left++;
                    else{
                        result.push_back(vector<int>{nums[k],nums[i],nums[left],nums[right]});

                        while(right >left && nums[left] == nums[left + 1]) left++;      //去重
                        while(right >left && nums[right] == nums[right - 1]) right--;   //去重

                        left++;
                        right--;
                    }
                }
            }
        }

        return result;
    }
};
```

该题和三数之和类似，区别在于多一层for循环，第二层的变量取值范围是第一层的变量加1。

## 字符串

### 反转字符串

[344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/description/)

我的代码

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left = 0;
        int right = s.size()-1;
        char temp;  //中间保存

        while(right > left){
            //交换
            temp = s.at(left);
            s[left] = s[right];
            s[right] = temp;

            //移动下标
            left++;
            right--;
        }
    }
};
```

代码随想录给的解答

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        for (int i = 0, j = s.size() - 1; i < s.size()/2; i++, j--) {
            swap(s[i],s[j]);
        }
    }
};
```

### 反转字符串Ⅱ

[541. 反转字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string-ii/description/)

```c++
class Solution {
public:
    string reverseStr(string s, int k) {

        for(int i = 0; i < s.size();i+=2*k)
        {
            // 1. 每隔 2k 个字符的前 k 个字符进行反转
            if(i+k < s.size())
                reverse(s.begin() + i,s.begin() + i + k); // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
            else
                reverse(s.begin() + i,s.end());    // 3. 剩余字符少于 k 个，则将剩余字符全部反转。
        }

        return s;
    }
};
```

### 替换数字

[54. 替换数字（第八期模拟笔试） (kamacoder.com)](https://kamacoder.com/problempage.php?pid=1064)

```c++
#include <iostream>
using namespace std;
int main() {
    string s;
    while (cin >> s) {
        int sOldIndex = s.size() - 1;
        int count = 0; // 统计数字的个数
        for (int i = 0; i < s.size(); i++) {
            if (s[i] >= '0' && s[i] <= '9') {
                count++;
            }
        }
        // 扩充字符串s的大小，也就是将每个数字替换成"number"之后的大小
        s.resize(s.size() + count * 5);
        int sNewIndex = s.size() - 1;
        // 从后往前将数字替换为"number"
        while (sOldIndex >= 0) {
            if (s[sOldIndex] >= '0' && s[sOldIndex] <= '9') {
                s[sNewIndex--] = 'r';
                s[sNewIndex--] = 'e';
                s[sNewIndex--] = 'b';
                s[sNewIndex--] = 'm';
                s[sNewIndex--] = 'u';
                s[sNewIndex--] = 'n';
            } else {
                s[sNewIndex--] = s[sOldIndex];
            }
            sOldIndex--;
        }
        cout << s << endl;       
    }
}
```

本题的关键在于统计字符串内数字的个数，通过数字的个数来扩容原来的字符串，然后从后往前填充对应的单词。

### 反转字符串中的单词

[151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/description/)

使用stringstream方法

[【C++】stringstream类 最全超详细解析（什么是stringstream？ stringstrem有哪些作用? 如何在算法中应用？）-CSDN博客](https://blog.csdn.net/weixin_45031801/article/details/136921743)

```c++
class Solution {
public:
    string reverseWords(string s) {
        string res,temp;
        stringstream ss(s);

        while(ss >> temp)   //从字符串流中按照空格分割提取
        {
            res = temp + " " + res; //调换顺序添加一个空格
        }
        if(!res.empty())        //移除最后添加的多余空格
            res.pop_back();
        return res;
    }
};
```

代码随想录不使用库函数的例子

```c++
class Solution {
public:
    void reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []
        for (int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }

    void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。
        int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html
        for (int i = 0; i < s.size(); ++i) { //
            if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。
                if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
                while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。
                    s[slow++] = s[i++];
                }
            }
        }
        s.resize(slow); //slow的大小即为去除多余空格后的大小。
    }

    string reverseWords(string s) {
        removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。
        reverse(s, 0, s.size() - 1);
        int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。
        for (int i = 0; i <= s.size(); ++i) {
            if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。
                reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。
                start = i + 1; //更新下一个单词的开始下标start
            }
        }
        return s;
    }
};
```

### 右旋字符串

[55. 右旋字符串（第八期模拟笔试） (kamacoder.com)](https://kamacoder.com/problempage.php?pid=1065)

```c++
#include <iostream>
#include <algorithm>

using namespace std;

int main(){
    int num;
    string s;
    cin >> num;
    cin >> s;
    int lenth = s.size();
    
    reverse(s.begin(),s.begin() + lenth);       //全部反转
    reverse(s.begin(),s.begin() + num);         //前n个反转
    reverse(s.begin() + num,s.end());         //反转length-n个
    
    cout << s << endl;  //结果输出
}
```

思路：将字符串先整个颠倒，然后根据输入的n去颠倒两个子字符串

### 找出字符串中第一个匹配的下标

[28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

```c++
class Solution {
public:
    int strStr(string haystack, string needle) {
        int haystacklength = haystack.size();
        int needlelength = needle.size();

        if(haystacklength < needlelength) //haystack长度小于needle，不可能
            return -1;

        int hindex = 0;     //haystack的指针
        int hindexcp = 0;   //haystack的复制指针，用于小窗内遍历检测
        int nindex = 0;     //needle的指针

        for(hindex = 0;hindex < haystacklength;hindex++){
            hindexcp = hindex;  //复制指针，用于小窗匹配
            while(haystack[hindexcp] == needle[nindex]){
                if(nindex == needlelength -1)
                    return hindex;
                hindexcp++;
                nindex++;
            }
            nindex = 0; //匹配错误，needle的指针归零
        }
        return -1;      //没有找到
    }
};
```

我自己的思路就是通过遍历haystack的下标，然后根据needle的长度用一个小窗去匹配。

KMP算法

前缀表（不减一）C++实现

```c++
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        vector<int> next(needle.size());
        getNext(&next[0], needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {		//不匹配跳回前缀表上一个下标
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {	//部分匹配移动下标
                j++;
            }
            if (j == needle.size() ) {	//匹配完成，返回下标
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

### 重复的子字符串

#### 移动匹配

判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。

当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。

```c++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string t = s + s;
        t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾
        if (t.find(s) != std::string::npos) return true; // r
        return false;
    }
};
```

#### KMP算法

```c++
class Solution {
public:
    void getNext(int *next,const string& s){
        int j = 0;
        next[0] = 0;
        for(int i = 1;i < s.size(); i++){
            while(j > 0 && s[i] != s[j]){
                j = next[j - 1];
            }
            if(s[i] == s[j]){
                j++;
            }
            next[i] = j;
        }
    }

    bool repeatedSubstringPattern(string s) 
    {
        vector<int> next(s.size());
        getNext(&next[0],s);        //获取前缀表

        int len = s.size();

        if(next[len-1] != 0 && len % (len - next[len - 1]) == 0)  //判断最长前后缀多余的部分能否被总长度整除
            return true;
        else
            return false;
    }
};
```

## 双指针法

该章节内部基本都是之前的题目

### 移除元素

[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/)

我自己的解答

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int i = 0;  //首指针
        int j = nums.size() - 1;    //尾指针
        int count = 0;

        if(nums.size() == 0) return 0;  //如果是空数组，则直接返回0

        sort(nums.begin(),nums.end());

        //统计符合val的个数
        for(auto num : nums)
        {
            if(num == val)
                count++;
        }

        while(i<j)
        {
            if(nums[i] == val){     //找到需要移除的元素
                nums[i] = nums[j];  //获取尾指针的数值
                j--;
            }
            i++;
        }
        return nums.size() - count; //返回总长度减去符合val的个数
    }
};
```

我的思路是先判断数组是否为空，如果为空立即返回0。然后开始对数组进行排序，遍历数组，寻找等于val的个数，最后的返回值就是总长度减找到的个数，通过双指针，一前一尾，如果等于val就和最后的交换（因为已经排过序所以不担心尾指针指向val）。

代码随想录的示例代码，该题和数组里面的移除元素一致

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;
    }
};
```

## 栈与队列

### 用栈实现队列 

```c++
class MyQueue {
public:
    stack<int> stack_in;        //入栈
    stack<int> stack_out;       //出栈

    MyQueue() {

    }
    
    void push(int x) {
        stack_in.push(x);
    }
    
    int pop() {
        int result = 0;

        //如果出栈为空，去入栈获取所有数据
        if(stack_out.empty()){
            while(!stack_in.empty()){
                stack_out.push(stack_in.top());
                stack_in.pop();
            }
        }
        result = stack_out.top();
        stack_out.pop();
        return result;
    }
    
    int peek() {
        int result = 0;
        result = this->pop();
        stack_out.push(result);
        return result;
    }
    
    bool empty() {
        if(stack_out.empty() && stack_in.empty())
            return true;
        else
            return false;
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

### 用队列实现栈

[225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/)

我的思路如下，将入队列和出队列的转移数据单独写成一个函数

```c++
class MyStack {
public:
    queue<int> queue_in;        //入队列
    queue<int> queue_out;       //出队列
    vector<int> temp;

    MyStack() {

    }

    void queue_in_to_queue_out(){

        //如果入队列有数据，全部放到temp中
        while(!queue_in.empty()){
            temp.push_back(queue_in.front());
            queue_in.pop();
        }

        reverse(temp.begin(),temp.end());  //翻转容器，让入队列的值在最前面

        //如果出队列有数据，全部放到temp中
        while(!queue_out.empty()){
            temp.push_back(queue_out.front());
            queue_out.pop();
        }

        //将temp中的值放回出队列中
        for(int i = 0; i < temp.size(); i++)
        {
            queue_out.push(temp[i]);
        }
        temp.clear();
    }
    
    void push(int x) {
        queue_in.push(x);
    }
    
    int pop() {
        this->queue_in_to_queue_out();  //队列操作

        int result = queue_out.front();
        queue_out.pop();    //pop处理
        return result;
    }
    
    int top() {
        this->queue_in_to_queue_out();  //队列操作

        int result = queue_out.front();
        return result;
    }
    
    bool empty() {
        if(queue_in.empty() && queue_out.empty())
            return true;
        else
            return false;
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

代码随想录的方法用一个队列就能实现

使用类似循环队列的思路完成

```c++
class MyStack {
public:
    queue<int> queue;

    MyStack() {

    }

    void push(int x) {
        queue.push(x);
    }
    
    int pop() {
        //使用循环队列的方式，将size-1个元素移动到尾部
        int size = queue.size();
        size--;

        while(size--)
        {
            queue.push(queue.front());
            queue.pop();
        }

        int result = queue.front();
        queue.pop();    //pop处理
        return result;
    }
    
    int top() {
        int result = queue.back();
        return result;
    }
    
    bool empty() {
        if(queue.empty())
            return true;
        else
            return false;
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

### 有效的括号

[20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/description/)

我的想法用switch，确实会比else if麻烦

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<char> m_stack;
        char rightchar;

        int size = s.size();
        if(size%2 != 0) return false;       //s长度为奇数必然不匹配

        for(int i = 0; i < s.size(); i++){
            switch(s[i]){
                //根据左括号往栈中加入右括号
                case '(': m_stack.push(')');break;
                case '[': m_stack.push(']');break;
                case '{': m_stack.push('}');break;

                //遇到右括号去栈顶寻找
                case ')': 
                    if(m_stack.empty())   return false; //如果空栈说明不匹配，直接退出
                    rightchar = m_stack.top();          //取栈顶元素
                    if(rightchar != s[i])   return false;   //如果不匹配就错误退出
                    m_stack.pop();                      //匹配则弹出，继续下一个匹配
                    break;

                case ']': 
                    if(m_stack.empty())   return false;
                    rightchar = m_stack.top();
                    if(rightchar != s[i])   return false;
                    m_stack.pop();
                    break;

                case '}': 
                    if(m_stack.empty())   return false;
                    rightchar = m_stack.top();
                    if(rightchar != s[i])   return false;
                    m_stack.pop();
                    break;
            }
        }

        return m_stack.empty(); //遍历完字符串，栈为空说明匹配成功
    }
};
```

代码随想录的方法

```c++
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求
        stack<char> st;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') st.push(')');
            else if (s[i] == '{') st.push('}');
            else if (s[i] == '[') st.push(']');
            // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false
            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false
            else if (st.empty() || st.top() != s[i]) return false;
            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素
        }
        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true
        return st.empty();
    }
};
```

第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false

第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false

第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false

### 删除字符串中的所有相邻重复项

[1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

我的写法

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        stack<char> st;
        string res;

        for(int i = 0; i < s.size(); i++){
            if(st.empty()){   //如果栈为空先放入
                st.push(s[i]);   
                continue;
            }

            if(st.top() == s[i]){
                st.pop();       //相同则弹出，消去
            }else{
                st.push(s[i]);  //不同则压入
            }
        }

        //如果栈非空意味着有剩余字符串，放到res中
        while(!st.empty())
        {
            res.push_back(st.top());
            st.pop();
        }

        //栈中为倒序，需要在颠倒一下
        reverse(res.begin(),res.end());

        return res;
    }
};
```

代码随想录还有一种用字符串模拟栈的方法

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        string res;

        for(char c :s){     //遍历字符串
            if(res.empty() || res.back() != c){ //字符串为空或者最后一个元素不等于c
                res.push_back(c);   //将c放到字符串尾部
            }else{
                res.pop_back();     //删除字符串尾部
            }
        }
        return res;
    }
};
```

### 逆波兰表达式求值

[150. 逆波兰表达式求值 - 力扣（LeetCode）](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

我的思路

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        int temp1,temp2,tempres;       //中间变量

        for(int i = 0; i < tokens.size();i++){
            if(tokens[i] >= "0" && tokens[i] <= "9" || tokens[i].size() > 1){    //如果是数字
                st.push(stoi(tokens[i]));
            }else{              //运算符
                temp1 = st.top();
                st.pop();
                temp2 = st.top();
                st.pop();

                if(tokens[i] == "+"){
                    tempres = temp1 + temp2;
                }else if(tokens[i] == "-"){
                    tempres = temp2 - temp1;
                }else if(tokens[i] == "*"){
                    tempres = temp1 * temp2;
                }else if(tokens[i] == "/"){
                    tempres = temp2 / temp1 ;
                }

                st.push(tempres);       //结果压入栈内
            }
            if(i == tokens.size() - 1)
                return st.top();
        }
        return 0;
    }
};
```

代码随想录的代码，如果先判断运算符可以简化不少

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        // 力扣修改了后台测试数据，需要用longlong
        stack<long long> st; 
        for (int i = 0; i < tokens.size(); i++) {
            if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") {
                long long num1 = st.top();
                st.pop();
                long long num2 = st.top();
                st.pop();
                if (tokens[i] == "+") st.push(num2 + num1);
                if (tokens[i] == "-") st.push(num2 - num1);
                if (tokens[i] == "*") st.push(num2 * num1);
                if (tokens[i] == "/") st.push(num2 / num1);
            } else {
                st.push(stoll(tokens[i]));
            }
        }

        int result = st.top();
        st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事）
        return result;
    }
};
```

### 滑动窗口最大值

[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/description/)

我自己的写法在超大数据量是直接超出时间，不可用。

难点是如何求一个区间里的最大值呢？ （这好像是废话），暴力一下不就得了。

暴力方法，遍历一遍的过程中每次从窗口中再找到最大的数值，这样很明显是O(n × k)的算法。

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;        //返回数组
        queue<int> que;         //整形队列
        int max = INT_MIN;            //最大值记录
        int temp = INT_MIN;

        int size = nums.size();

        for(int i = 0; i < size; i++){
            if(que.size() < k){
                que.push(nums[i]);  //队列长度不到k则加入元素
            }
            if(que.size() == k){
                //取出数比较
                for(int j = 0; j < k; j++){
                    //取值并弹出
                    temp = que.front();
                    que.pop();
                    //如果为最大则记录
                    if(temp > max){
                        max = temp;
                    }
                    que.push(temp); //放回到末尾
                }
                res.push_back(max); 
                que.pop();  //移动去掉头
                max = INT_MIN;    //最大值赋值int最小
            }
        }
        return res;
    }
};
```

代码随想录的方法，自定义一个单调递减的队列

```c++
class Solution {
private:
    class Myqueue{  //单调队列（从大到小）
        public:
        deque<int> que;
        // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
        // 同时pop之前判断队列当前是否为空。
        void pop(int value){
            if(!que.empty() && que.front() == value)
                que.pop_front();
        }
        // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
        // 这样就保持了队列里的数值是单调从大到小的了。
        void push(int value){
            while(!que.empty() && que.back() < value)   //将队列中所以小于value的值全部弹出
                que.pop_back();
            que.push_back(value);
        }
        // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
        int GetMaxValue()
        {
            return que.front();     //队列最前面为最大值
        }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        Myqueue que;    //自定义队列
        vector<int> res;

        for(int i = 0; i < k;i++){  //将前k个先放入队列
            que.push(nums[i]);
        }
        res.push_back(que.GetMaxValue());

        for(int i = k; i < nums.size(); i++){
            que.pop(nums[i-k]); // 滑动窗口移除最前面元素
            que.push(nums[i]);  // 滑动窗口前加入最后面的元素
            res.push_back(que.GetMaxValue());   // 记录对应的最大值
        }
        return res;
    }
};
```

### 前K个高频元素

[347. 前 K 个高频元素 - 力扣（LeetCode）](https://leetcode.cn/problems/top-k-frequent-elements/description/)

本题主要考察对优先级队列的使用，同时需要考虑使用大堆顶还是小堆顶。

大堆顶每次pop的时候会将内部最大的值弹出，小队顶每次pop的时候会将内部最小的值弹出。

**所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。**

这边需要自己重写operator，完成从小到大的排序。

我自己稍作修改的写法

```c++
class Solution {
    // 小堆顶
    class mycomparsion {
    public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };

public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> map;

        // 统计各元素出现的次数
        for (int num : nums) {
            map[num]++;
        }

        // 遍历容器寻找出现次数最多的k个
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparsion> pri_que;
        for (auto it = map.begin(); it != map.end(); it++) { // 遍历容器
            pri_que.push(*it);
            if (pri_que.size() > k) { // 当堆中数量超过k时，pop会将频率最小的弹出
                pri_que.pop();
            }
        }

        // 倒序输出前K个高频
        vector<int> res(k); // 一个长度为k的容器
        for (int i = k - 1; i >= 0; i--) {
            res[i] = pri_que.top().first; // 将键放入容器中
            pri_que.pop();
        }

        return res;
    }
};
```

代码随想录的写法

```c++
class Solution {
public:
    // 小顶堆
    class mycomparison {
    public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 要统计元素出现频率
        unordered_map<int, int> map; // map<nums[i],对应出现的次数>
        for (int i = 0; i < nums.size(); i++) {
            map[nums[i]]++;
        }

        // 对频率排序
        // 定义一个小顶堆，大小为k
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

        // 用固定大小为k的小顶堆，扫面所有频率的数值
        for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {
            pri_que.push(*it);
            if (pri_que.size() > k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
                pri_que.pop();
            }
        }

        // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--) {
            result[i] = pri_que.top().first;
            pri_que.pop();
        }
        return result;

    }
};
```

## 动态规划

### 斐波那契数

[509. 斐波那契数 - 力扣（LeetCode）](https://leetcode.cn/problems/fibonacci-number/description/)

我的解答

```c++
class Solution {
public:
    int fib(int n) {
        int res;

        if(n > 1)  res = fib(n-1) + fib(n-2);   //n大于1，F(n) = F(n - 1) + F(n - 2)
        if(n == 1)  res = 1;                    //F(1) = 1
        if(n == 0)  res = 0;                    //F(0) = 0

        return res;
    }
};
```

代码随想录给出的解答

```c++
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        vector<int> dp(N + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
};
```



# 笔试遇到的题目

## 大疆

### 合并K个升序链表

[23. 合并 K 个升序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-k-sorted-lists/)

优先级队列 小堆顶法

```c++
class Solution {
public:
    struct compare{
        bool operator()(ListNode* a,ListNode* b){
            return a->val > b->val;
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*,vector<ListNode*>,compare> pq;     //优先级队列，小堆顶

        // 将每个链表的首节点放入优先队列
        for(auto list:lists){
            if(list)
                pq.push(list);
        }

        //虚拟头节点
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;

        // 不断从优先队列中取出最小的节点，连接到合并后的链表上
        while(!pq.empty()){
            ListNode* node = pq.top();
            pq.pop();
            current->next = node;
            current = current->next;

             // 如果该节点后面还有节点，继续放入优先队列
            if(node->next) {
                pq.push(node->next);
            }
        }

        return dummy->next;
    }
};
```

顺序合并 用一个变量 p来维护以及合并的链表，第 i 次循环把第 i个链表和 p合并，答案保存到 p中

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:

    ListNode *merge2(ListNode *l1,ListNode *l2){
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy;

        //l1和l2都没遍历完，选择小的挂在链表
        while(l1 and l2){
            if(l1->val<l2->val){
                p->next = l1;
                l1 = l1->next;
            }
            else{
                p->next = l2;
                l2 = l2->next;
            }
            p=p->next;
        }

        //l1和l2其中一个如果遍历完了
        p->next = l1 ? l1 : l2; //直接挂在链表
        return dummy->next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int size = lists.size();
        if (size == 0){
            return nullptr;
        }
        if (size == 1){
            return lists[0];
        }
        auto p = lists[0];
        for(int i = 1;i<size;i++){
             p=merge2(p,lists[i]);
        }
        return p;
    }
};
```

[21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

该题为简化版，两个链表合并

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;

        while(list1 != nullptr && list2 != nullptr){
            if(list1->val < list2->val){    //小的先进入链表
                current->next = list1;
                list1 = list1->next;
            }else{
                current->next = list2;
                list2 = list2->next;
            }

            current = current->next;    //移动到下一个
        }

        //如果list1非空，就将list1挂在链表尾部
        if(list1 != nullptr) 
            current->next = list1;
        else
            current->next = list2;

        return dummy->next;
    }
};
```



### 二分查找

[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/description/)

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return left;	//这里是大疆题目和704二分查找的差异，要求返回target的插入位置
    }
};
```

## 美团

### 识别字符串的类型

输入“123 adc a23” 返回"NUMBER WORD MIXED"

```c++
#include <iostream>
#include <sstream>
#include <vector>

using namespace std;

int main() {
    string strs;
    getline(cin, strs);
    stringstream ss(strs);

    vector<string> vc;
    string str;
    while (ss >> str)
    {
        vc.push_back(str);
    }

    for (int i = 0; i < vc.size(); i++)
    {
        int numcount = 0;
        for (int j = 0; j < vc[i].size(); j++)
        {

            if (vc[i].at(j) >= '0' && vc[i].at(j) <= '9')
                numcount++;
        }
        if (numcount == vc[i].size())
        {
            //vc[i] = "NUMBER";
            cout << "NUMBER" << ' ';        //数字
        }
        else if (numcount == 0)
        {
            //vc[i] = "WORD";
            cout << "WORD" << ' ';          //单词
        }
        else {
            //vc[i] = "MIXED";
            cout << "MIXED" << ' ';         //混合
        }
    }

}
```

### 植树数量问题

输入：

“3 6”代表工人数量 最少树的数量

“ 1 2 5” 代表工人的位置

输出：求树的最小间距，每个工人只能往右边种树，一个位置上只能种1棵。 上例输出为3

```c++
#include <climits>
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

int main() {
    int n, k;   //n工人数量，k最少树的数量
    cin >> n >> k;
    int n_copy = n;

    vector<int> vc;
    int num;
    while (n--) {
        cin >> num;
        vc.push_back(num);
    }
    sort(vc.begin(), vc.end());

    int min_interval = 1; //最小间距
    int treenum = 0;
    while (treenum < k) {

        treenum = min_interval * vc.size();

        for (int i = 1; i < vc.size(); i++)
        {
            if (vc[i] < vc[i - 1] + min_interval)
            {
                treenum = treenum - (min_interval - vc[i] + vc[i - 1]);
            }
        }
        cout << "treenum" << treenum << endl;
        min_interval++;
    }

    cout << min_interval - 1;
}

//输入实例
// 3 6
// 1 2 5
```

# 力扣最热100

## [两数之和](https://leetcode.cn/problems/two-sum/)

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> map;     //键为nums数值，值为下标

        for(int i = 0;i < nums.size();i++)
        {
            auto iter = map.find(target - nums[i]); //寻找差值

            if(iter != map.end())   //找到就返回下标
                return {iter->second,i};
            else                    //没找到就存入map
                map.insert(pair<int,int>(nums[i],i));
        }
        return {0,0};
    }
};
```

## [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>> mp;    //创建一个无序映射
        string key;

        //遍历输入，将每个项排序，字母异位词排序后相同
        for(int i = 0;i < strs.size();i++)
        {
            key = strs[i];
            sort(key.begin(),key.end()); //排序
            mp[key].emplace_back(strs[i]);
        }

        vector<vector<string>> res;
        //遍历map将所有值输出
        for(auto iter = mp.begin();iter != mp.end();iter++)
        {
            res.push_back(iter->second);
        }
        return res;
    }
};
```

## [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        if(nums.empty())    //数组为空
            return 0;

        //排序，从小到大
        sort(nums.begin(),nums.end());

        int length = 1;         //长度统计
        int maxlength = 1;      //最长长度
        int temp = nums[0];

        for(int i = 1; i < nums.size();i++)
        {
            if(nums[i] == temp) //重复跳过
            {
                temp = nums[i];
                continue;
            }
            if(nums[i] == temp + 1) //符合要求，长度加一
            {
                length++;
            }
            else
            {
                maxlength = max(maxlength,length);      //保存最长的长度
                length = 1;
            }
            temp = nums[i];
        }
        return max(maxlength,length);   //返回最长的长度
    }
};
```

## [移动零](https://leetcode.cn/problems/move-zeroes/)

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if(nums.empty())    return;

        int SlowIndex = 0;  //慢指针
        //快指针遍历，将非0元素保存到慢指针上
        for(int FastIndex = 0; FastIndex < nums.size();FastIndex++)
        {
            if(nums[FastIndex] != 0)
            {
                nums[SlowIndex++] = nums[FastIndex];
            }
        }

        //将慢指针到结尾的地方补上0
        for(;SlowIndex < nums.size();SlowIndex++)
        {
            nums[SlowIndex] = 0;
        }
    }
};
```

## [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int MaxResult = 0;
        int CurrentResult = 0;

        if(height.empty()) return 0;

        int LeftIndex = 0;
        int RightIndex = height.size()-1;

        //两边指针往中间动
        while(LeftIndex < RightIndex)
        {
            //计算水量
            CurrentResult = (RightIndex-LeftIndex)*min(height[RightIndex],height[LeftIndex]);
            //取两者最大
            MaxResult = max(MaxResult,CurrentResult);
            //移动指针，那块板小，移动那边的指针
            if(height[RightIndex] < height[LeftIndex])
                RightIndex--;
            else
                LeftIndex++;
        }
        return MaxResult;
    }
};
```

## [接雨水](https://leetcode.cn/problems/trapping-rain-water/)

![image-20240827104802617](./代码随想录刷题.assets/image-20240827104802617.png)

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if(n==0)    return 0;

        vector<int> leftMax(n);
        leftMax[0] = height[0];
        for(int i = 1;i < n;++i){
            leftMax[i] = max(leftMax[i-1],height[i]);
        }

        vector<int> rightMax(n);
        rightMax[n-1] = height[n-1];
        for(int i = n-2;i >= 0;--i){
            rightMax[i] = max(rightMax[i+1],height[i]);
        }

        int ans = 0;
        for(int i = 0;i < n;++i)
        {
            ans += min(leftMax[i],rightMax[i]) - height[i];
        }
        return ans;
    }
};
```



## [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char,int> map;    //创建一个map
        int curlength = 0;
        int Maxlength = 0;
        
        if(s.size() == 1) return 1;

        for(int left = 0,right = 0;right < s.size();right++)
        {
            map[s[right]]++;
            while(map[s[right]] == 2)//发现重复
            {
                //将左边界元素拿出，移动下标
                map[s[left]]--;
                left++;
            }

            curlength = right - left + 1;
            Maxlength = max(Maxlength,curlength);
        }
        return max(Maxlength,curlength);
    }
};
```

## [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int m = s.size();
        int n = p.size();

        if(m < n)   return {};       //如果s的长度小于p，直接返回
        vector<int> hash(26);        //存放26个字母

        //初始化p的字符数组然后维护数组每个元素不小于0。
        for(auto ch: p)
        {
            hash[ch - 'a']++;
        }

        vector<int> ret;
        //开始向右滑动窗口，减去并相应字符，如果频率小于0就收缩左侧边界直到频率不再小于0。窗口长度与p长度一致时达成条件。
        for(int l = 0,r = 0;r < m;++r)
        {
            hash[s[r] - 'a']--;
            while(hash[s[r] - 'a']<0)
            {
                hash[s[l] - 'a']++;
                l++;
            }
            if(r-l+1==n)    ret.push_back(l);
        }
        return ret;
    }
};
```

## [和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> mp;
        mp[0] = 1;
        int count = 0,pre = 0;
        for(auto& x:nums)
        {
            pre += x;
            if(mp.find(pre-k) != mp.end())
            {
                count += mp[pre - k];
            }
            mp[pre]++;
        }
        return count;
    }
};
```

## [最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int pre = 0;
        int maxRes = nums[0];
        for(int x:nums)
        {
            pre = max(pre+x,x); //只需要判断前缀和与前缀和与当前数值相加哪个大，大的那个继续参与后续比较
            maxRes = max(maxRes,pre);
        }
        return maxRes;
    }
};
```

只需要判断前缀和与前缀和与当前数值相加哪个大，大的那个继续参与后续比较。

## [合并区间](https://leetcode.cn/problems/merge-intervals/)

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if(intervals.size() == 0)
        return {};

        //先排序，后一次遍历，判断是否是一个区间 如 [1, 3], [2, 6]，当3大于等于2说明是一个区间，反之不是
        sort(intervals.begin(),intervals.end());

        for(int i = 1;i < intervals.size();i++)
        {
            //存在重叠的情况
            if(intervals[i-1][1] >= intervals[i][0])
            {
                //往nums中放入四个数，排序，然后选头尾
                vector<int> nums;
                nums.push_back(intervals[i-1][0]);
                nums.push_back(intervals[i-1][1]);
                nums.push_back(intervals[i][0]);
                nums.push_back(intervals[i][1]);
                sort(nums.begin(),nums.end());
                intervals[i-1][0] = nums[0];
                intervals[i-1][1] = nums[3];
                intervals.erase(intervals.begin()+i);
                i--;        //i的值回到上一个，防止遗漏
            }
        }
        return intervals;
    }
};
```

## [轮转数组](https://leetcode.cn/problems/rotate-array/)

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        queue<int> temp;

        //当k大于数组长度时，取余数，当k小于数组长度时，k等于自身
        k = k % nums.size();
        //将后k个放入队列
        for(int i = nums.size()-k; i < nums.size();i++)
            temp.push(nums[i]);
        //将前数组长度-k个放入队列
        for(int i = 0; i <= nums.size()-1-k;i++)
            temp.push(nums[i]);
        //遍历读取
        for(int i = 0; i < nums.size();i++){
            nums[i] = temp.front();
            temp.pop();
        }
    }
};
```

翻转法

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k%=nums.size();
        reverse(nums.begin(),nums.end());
        reverse(nums.begin(),nums.begin()+k);
        reverse(nums.begin()+k,nums.end());
    }
};
```

## [除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int length = nums.size();
        if(length == 0) return{};

        vector<int> answer(length);
        vector<int> Front(length);          //前缀积
        vector<int> Back(length);           //后缀积

        Front[0] = 1;                       //最左边和最右边积初始值为1
        Back[length-1] = 1;
        //前缀积求值，前缀积*前一个nums值
        for(int i = 1;i < length;i++)
            Front[i] = Front[i-1] * nums[i-1];
        //前缀积求值，后缀积*后一个nums值
        for(int i = length-2; i >= 0;i--)
            Back[i] = Back[i+1] * nums[i+1];
        //遍历数组，除自身以外的积等于前缀积*后缀积
        for(int i = 0;i < length;i++)
            answer[i] = Front[i] * Back[i];
        return answer;  
    }
};
```

## [缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

下面是我的写法，在元素重复的时候，我选择了集合，集合里不会有重复的数

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int length = nums.size();
        if(length == 0) return 0;

        set<int> numset;

        int FirstMiss = 1;      //1是最小的正整数
        sort(nums.begin(),nums.end());  //数组排序
        for(int num:nums)
            numset.insert(num);     //把数组元素放入集合中
        //遍历集合，元素小于1则跳过，大于1开始去匹配，再加1，直到没有符合正整数
        for(auto iter = numset.begin();iter != numset.end();iter++)
        {
            if(*iter < 1) continue;
            if(*iter == FirstMiss)
                FirstMiss++;
            else
                return FirstMiss;
        }
        return FirstMiss;
    }
};
```

高手的做法更加巧妙，不去判断小于res的情况

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        //先排序
        sort(nums.begin(),nums.end());
        int res=1;//未出现的最小正整数 从1开始枚举
        for(int i=0;i<nums.size();i++){
            //找数组中的最小正整数
            if(nums[i]<=0) continue;
            //然后和res比较
            if(nums[i]>res) return res;//大于res 直接返回res
            else if(nums[i]==res) res++;//等于res res++
            //小于res 不处理 因为后续可能出现大于等于res的情况或直至遍历完都小于res
        }
        return res;
    }
};
```

## [矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

我的方法就是用一个相同的矩阵去存放0的位置，有0的地方放1，最后遍历二维数组去置0

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size();          //行
        int n = matrix[0].size();       //列

        vector<vector<int>> Records(m,vector(n,0));

        //记录0的位置
        for(int i = 0; i < m;i++)
        {
            for(int j = 0; j < n;j++)
            {
                if(matrix[i][j] == 0)
                    Records[i][j] = 1;
            }
        }

        //遍历Records，置零操作
        for(int i = 0; i < m;i++)
        {
            for(int j = 0; j < n;j++)
            {
                //碰到0的位置，将一行一列置0
                if(Records[i][j] == 1)
                {
                    for(int j = 0; j < n;j++)
                        matrix[i][j] = 0;
                    for(int i = 0; i < m;i++)
                        matrix[i][j] = 0;
                }
            }
        }
    }
};
```

官方题解是用两个一维数组去存放，碰到0就将对应的行和列设置为true，最后通过两个数组去置零

## [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
    if(matrix.size() == 0 || matrix[0].size() == 0)
    return {};

    vector<int>ans;
    int lineBegin = 0, lineEnd = matrix[0].size() - 1; //记录行的开头与结尾
    int listBegin = 0, listEnd = matrix.size() - 1; //记录列的开头与结尾

    while(true)
    {
        //从左往右
        for(int i = lineBegin; i <= lineEnd; i++)
        ans.push_back(matrix[listBegin][i]);
        if(++listBegin > listEnd) break;

        //从上往下
        for(int i = listBegin; i <= listEnd; i++)
        ans.push_back(matrix[i][lineEnd]);
        if(--lineEnd < lineBegin) break;

        //从右往左
        for(int i = lineEnd; i >= lineBegin; i--)
        ans.push_back(matrix[listEnd][i]);
        if(--listEnd < listBegin) break;

        //从下往上
        for(int i = listEnd; i >= listBegin; i--)
        ans.push_back(matrix[i][lineBegin]);
        if(++lineBegin > lineEnd) break;
    }
    return ans;
    }
};
```

## [旋转图像](https://leetcode.cn/problems/rotate-image/)

虽然效果正确，但是不符合题意，使用了另一个数组

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        if(n == 0) return;

        auto matrix_new = matrix;
        for(int i=0;i < n;i++)
        {
            for(int j=0;j < n;j++)
            {
                matrix_new[j][n-i-1] = matrix[i][j];
            }
        }
        matrix = matrix_new;
    }
};
```

用翻转代替旋转，先水平轴翻转，在主对角线翻转即可

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        // 水平翻转
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < n; ++j) {
                swap(matrix[i][j], matrix[n - i - 1][j]);
            }
        }
        // 主对角线翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
};
```

## [搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

最简单的就是遍历矩阵去找

其次就是对每行进行二分查找

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }

    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        for(int i = 0;i < matrix.size();i++)
        {
            if(search(matrix[i],target)!=-1)
                return true;
        }

        return false;
    }
};
```

## [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int lengthA = 0;
        int lengthB = 0;
        int diff = 0;

        //使用另一个指针去遍历，防止破坏原链表
        ListNode* currA = headA;
        ListNode* currB = headB;

        //统计两个链表的长度
        while(currA!=NULL)
        {
            lengthA++;
            currA = currA->next;
        }

        while(currB!=NULL)
        {
            lengthB++;
            currB = currB->next;
        }

        //哪个长就先移动哪个
        if(lengthA > lengthB)
        {
            diff = lengthA-lengthB;
            while(diff--)
                headA = headA->next;
        }else
        {
            diff = lengthB-lengthA;
            while(diff--)
                headB = headB->next;
        }

        //寻找相交点
        while(headA != NULL && headB != NULL)
        {
            if(headA == headB)
                return headA;
            
            headA = headA->next;
            headB = headB->next;
        }

        return NULL;
    }
};
```

## [反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *pre = nullptr;
        ListNode *cur = head;

        while(cur != nullptr)
        {
            ListNode *temp = cur->next;     //保存temp下一节点
            cur->next = pre;                //将cur下一节点指向pre
            pre = cur;                      //pre移动到cur
            cur = temp;                     //cur按照原来的顺序移动到下一节点
        }
        return pre;
    }
};
```

## [回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

先用快慢指针找到中点，翻转后半部分链表，遍历两个链表看是否相同即回文。使用到了上面反转链表的函数

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head){
        ListNode *pre = nullptr;
        ListNode *cur = head;

        while(cur != nullptr)
        {
            ListNode *temp = cur->next;     //保存temp下一节点
            cur->next = pre;                //将cur下一节点指向pre
            pre = cur;                      //pre移动到cur
            cur = temp;                     //cur按照原来的顺序移动到下一节点
        }
        return pre;
    }

    bool isPalindrome(ListNode* head) {
        ListNode *rehead = new ListNode;
        ListNode* slow = head, *fast = head;
        // 快慢指针法找到中间节点
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
        }
        rehead = reverseList(slow); //翻转后半部分

        while(head != nullptr && rehead != nullptr)
        {
            if(head->val == rehead->val)
            {
                head = head->next;
                rehead = rehead->next;
            }else
                return false;
        }
        return true;
    }
};
```

还有就是将链表中的值放入一个数组，然后快慢指针对前后值进行比对。

```c++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector<int> vals;
        //将所有链表值放入数组中
        while (head != nullptr) {
            vals.emplace_back(head->val);
            head = head->next;
        }
        //用快慢指针左右往中间判断是否相同
        for (int i = 0, j = (int)vals.size() - 1; i < j; ++i, --j) {
            if (vals[i] != vals[j]) {
                return false;
            }
        }
        return true;
    }
};
```

## [环形链表](https://leetcode.cn/problems/linked-list-cycle/)

思路就是使用快慢指针，快指针每次动两步，慢指针每次动一步，如果有环，快指针一定会与慢指针相遇

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;

        while(fast != NULL && fast->next != NULL) //快指针多动一步，有环必追上
        {
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow)        //相等说明有环
                return true;
        }
        return false;
    }
};
```

## [环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

思路与上题相同，关键在于最后寻找入环点。使用的方法就是从链表头和快指针点同时移动，直到两者相遇，就是入环点。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fastnode = head;      //定义一个快指针指向链表头
        ListNode *slownode = head;      //定义一个慢指针指向链表头

        while(fastnode != NULL && fastnode->next != NULL)
        {
            fastnode = fastnode->next->next;        //快指针每次运动两个节点
            slownode = slownode->next;              //慢指针每次运动一个节点

            if(fastnode == slownode)        //快慢节点相遇
            {
                //从链表头和快指针头同时开始移动，相遇则入环点
                ListNode* index1 = head;
                ListNode* index2 = fastnode;
                while(1)
                {
                    if(index1==index2)  return index1;
                    index1 = index1->next;
                    index2 = index2->next;
                }
            }
        }

        return NULL;
    }
};
```

## [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

思路：两个链表都不为空时，选择小的那个放入新链表。直到两个链表中的其中一个为空。再去判断哪个链表还有数据，放到新链表后。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;      //用于操作的链表头

        while(list1 != nullptr && list2 != nullptr)
        {
            if(list1->val < list2->val)
            {
                cur->next = list1;
                list1 = list1->next;
            }
            else
            {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        //如果list1非空，就将list1挂在链表尾部
        if(list1 != nullptr)
            cur->next = list1;
        else
            cur->next = list2;

        return dummy->next;     //返回的是虚拟头节点的下一节点
    }
};
```

## [两数相加](https://leetcode.cn/problems/add-two-numbers/)

思路：两个链表对应位置相加，如果超过10则进位，往新链表中放入值%10的余数。遍历完之后如果还有进位，则需要在创建一个进位节点。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *res =  new ListNode(0);
        ListNode *cur = res;
        int overten = 0;
        while(l1 != nullptr || l2 != nullptr)
        {
            int num = 0;
            //l1非空，num加值
            if(l1 != nullptr){
                num += l1->val;
                l1 = l1->next;
            }
            //l2非空，num加值
            if(l2 != nullptr){
                num += l2->val;
                l2 = l2->next;
            }
            //加上进位，/10算进位，%算个位
            num += overten;
            overten = num /10;
            cur->next = new ListNode(num%10);
            cur = cur->next;
        }

        if(overten)     //如果还有进位，则在最前面加一个
            cur->next = new ListNode(overten);

        return res->next;
    }
};
```

## [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

思路：使用虚拟头节点去操作快慢节点，先让快节点动n+1步，再同时移动，直到快节点为空，此时慢节点的下一节点为倒数第N个节点，重新指向就可以删除。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *dummy = new ListNode(0);  //虚拟头节点
        dummy->next = head;

        ListNode *fast = dummy;
        ListNode *slow = dummy;

        n+=1;           //多加了虚拟头节点，所以多加1
        while(n--)      //快节点先移动n+1步
        {
            fast = fast->next;
        }

        while(fast != nullptr)      //同时移动直到快指针指向null
        {
            fast = fast->next;
            slow = slow->next;
        }
        //此时slow指向的就是倒数第N+1个节点
        ListNode *temp = slow->next;
        slow->next = slow->next->next;      //删除下一个节点，即倒数第N个
        delete temp;
        return dummy->next;
    }
};
```

## [两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

思路：构建虚拟头节点方便操作，先判断下个节点和下下个节点是否为空，使用两个临时变量保存下一节点和下下下一节点，根据两两交换的特性去重新定向，最后返回虚拟头节点的下一节点就是原链表。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        ListNode* cur = dummy;
        //非空判断
        while(cur->next != nullptr && cur->next->next != nullptr)
        {
            ListNode *temp1 = cur->next;                //保存下一节点
            ListNode *temp2 = cur->next->next->next;    //保存下下下一节点
            //重新定向
            cur->next = cur->next->next;
            cur->next->next = temp1;
            cur->next->next->next = temp2;
            //移动两步
            cur = cur->next->next;
        }
        return dummy->next;
    }
};
```

## [K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

思路：使用虚拟头节点，需要把链表节点按照 k 个一组分组，所以可以使用一个指针 head 依次指向每组的头节点。这个指针每次向前移动 k 步，直至链表结尾。对于每个分组，我们先判断它的长度是否大于等于 k。若是，我们就翻转这部分链表，否则不需要翻转。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 翻转一个子链表，并且返回新的头与尾
    pair<ListNode*,ListNode*> myReverse(ListNode* head,ListNode* tail)
    {
        ListNode* prev = tail->next;
        ListNode* p = head;
        while(prev != tail)
        {
            ListNode* nex = p->next;
            p->next = prev;
            prev = p;
            p = nex;
        }
        return {tail,head};
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* hair = new ListNode(0);
        hair->next = head;
        ListNode* pre = hair;

        while (head) {
            ListNode* tail = pre;
            // 查看剩余部分长度是否大于等于 k
            for (int i = 0; i < k; ++i) {
                tail = tail->next;
                if (!tail) {
                    return hair->next;
                }
            }
            ListNode* nex = tail->next;
            // 这里是 C++17 的写法，也可以写成
            pair<ListNode*, ListNode*> result = myReverse(head, tail);
            head = result.first;
            tail = result.second;
            //tie(head, tail) = myReverse(head, tail);
            // 把子链表重新接回原链表
            pre->next = head;
            tail->next = nex;
            pre = tail;
            head = tail->next;
        }

        return hair->next;
    }
};
```

## [随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

思路：利用递归和哈希表，使用哈希表判断该节点是否拷贝过，如果没有拷贝则进行拷贝，对于后继节点和随机指针节点则采用递归的方式去遍历。

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    unordered_map<Node*,Node*> cachedNode;

    Node* copyRandomList(Node* head) {
        if(head == NULL)
            return NULL;
        
        if(!cachedNode.count(head)){        //如果在map中不能找到head
            Node* headNew = new Node(head->val);
            cachedNode[head] = headNew;                         //哈希表记录
            headNew->next = copyRandomList(head->next);         //递归创建后继节点
            headNew->random = copyRandomList(head->random);     //递归创建随机指针指向的节点
        }
        
        return cachedNode[head];
    }
};
```

## [排序链表](https://leetcode.cn/problems/sort-list/)

思路：先遍历一遍链表，将所有数据保存在容器中。再对容器进行从小到大排序。最后将容器中的数取出构建新的链表。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector<int> vc;
        //遍历链表，往容器中放入元素
        while(head!=nullptr)
        {
            vc.push_back(head->val);
            head = head->next;
        }
        sort(vc.begin(),vc.end());      //从小到大排序

        ListNode * res = new ListNode(0);   //虚拟头节点
        ListNode * cur = res;               //使用cur去遍历
        for(int num: vc)
        {
            cur->next = new ListNode(num);
            cur = cur->next;
        }
        return res->next;           //返回虚拟节点的下一节点
    }   
};

```

## [搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

经典二分查找

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size()-1;

        while(left <= right)
        {
            int mid = left + (right - left)/2;
            if(nums[mid] == target) return mid;
            else if(nums[mid] < target)
                left = mid + 1;
            else
                right = mid -1;
        }
        return left;
    }
};
```

## [搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

该题类似[240. 搜索二维矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/)都是使用二分查找对每一行进行查找。

```c++
class Solution {
public:
    // 二分查找
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return -1;
    }

    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        //遍历每一行去找target
        for (int i = 0; i < matrix.size(); i++) {
            if (search(matrix[i], target) != -1)
                return true;
        }
        return false;
    }
};
```

## [在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

思路：首先使用二分查找找到target的其中一个位置，然后开始向左右两边继续寻找target，如果值变化或者越界则停止。最后返回的左下标需要加1，右下标需要减1。

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) { // 找到target，开始往两边查找
                int l = mid;
                int r = mid;
                while (nums[l] == target) {
                    l--;
                    if (l < 0) // 越界代表无法找到
                        break;
                }
                while (nums[r] == target) {
                    r++;
                    if (r > nums.size() - 1) // 越界代表无法找到
                        break;
                }
                return {l + 1, r - 1}; // 因为左右都多移了一步，要补回来
            } else if (nums[mid] < target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return {-1, -1};
    }
};
```

## [搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

我的思路，寻找反转点，先看中点数值与最右侧数值相比，中点数值大于最右侧则说明中值往左都是有序的，mid慢慢向右移动，直到nums[mid]小于最右侧的值，再对两端有序数组进行二分查找，另一种中点数值小于最右侧的情况类似。

```c++
class Solution {
public:
    //二分查找搜索函数，left和right为搜索边界
    int searchInsert(vector<int>& nums, int target, int left, int right) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return -1;
    }

    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int mid = left + (right - left) / 2;
        int res = -1;
        //长度为一且相等直接返回
        if (nums.size() == 1 && nums[0] == target)
            return 0;

        if (nums[mid] > nums[right]) // mid左边有序，右边不一定
        {
            //寻找反转点
            while (nums[mid] > nums[right]) {
                mid++;
                if (mid > nums.size() - 1) {        //防止越界
                    mid = nums.size() - 1;
                    break;
                }
                if (nums[mid] < nums[right])        //找到反转点
                    break;
            }
            res = searchInsert(nums, target, mid, right);       //分段搜索
            if (res != -1)
                return res;
            res = searchInsert(nums, target, left, mid - 1);    //分段搜索
            if (res != -1)
                return res;
        } else if (nums[mid] < nums[right]) // mid右边有序，左边不一定
        {
            //寻找反转点
            while (nums[mid] < nums[right]) {       //防止越界
                mid--;
                if (mid < 0) {
                    mid = 0;
                    break;
                }
                if (nums[mid] > nums[right])        //找到反转点
                    break;
            }
            res = searchInsert(nums, target, left, mid);        //分段搜索
            if (res != -1)
                return res;
            res = searchInsert(nums, target, mid + 1, right);   //分段搜索
            if (res != -1)
                return res;
        }

        return -1;
    }
};
```

官方题解：

![fig1](https://assets.leetcode-cn.com/solution-static/33/33_fig1.png)

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = (int)nums.size();
        if (!n) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};
```

## [寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

其实有点偷鸡摸狗了，最后的返回值是从mid和mid+1中选小的那个，需要考虑越界问题。

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        int mid = 0;

        if(nums.size() == 1)    return nums[0];

        while (left < right) {
            mid = left + (right - left) / 2;
            if (nums[mid] > nums[right]) // 最小值在右边
                left = mid + 1;
            else // 最小值在左边
                right = mid;
        }

        if(mid + 1 != nums.size())          //如果mid+1不越界，就选mid和mid+1小的那个
            return min(nums[mid],nums[mid+1]);
        else
            return nums[mid];
    }
};
```

官方解答

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        int mid = 0;

        if(nums.size() == 1)    return nums[0];

        while (left < right) {
            mid = left + (right - left) / 2;
            if (nums[mid] > nums[right]) // 最小值在右边
                left = mid + 1;
            else // 最小值在左边
                right = mid;
        }
        return nums[left];
    }
};
```

## [有效的括号](https://leetcode.cn/problems/valid-parentheses/)

思路：遇到左括号，将对应的右括号放入栈中，如果栈为空或者栈顶元素不等于c 返回false。相等则将栈顶元素弹出。遍历完最后检查一遍栈的大小。

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<int> st;      //栈

        for(char c:s)
        {
            if(c == '(') st.push(')');
            else if(c == '{') st.push('}');
            else if(c == '[') st.push(']');         //加入相对的字符到栈中
            else if(st.empty() || st.top() != c)    //如果栈为空或者栈顶元素不等于c 返回false
                return false;
            else
                st.pop();
        }

        if(!st.empty())         //检查栈是否为空
            return false;
        else
            return true;
    }
};
```

## [二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

使用递归的方式：需要根据遍历次序将vec.push_back(root->val);放在对应位置上。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void Traversal(TreeNode *root,vector<int>& vec)
    {
        if(root == nullptr)     //发现null返回
            return;
        //中序遍历 前中右顺序
        Traversal(root->left,vec);
        vec.push_back(root->val);
        Traversal(root->right,vec);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        Traversal(root,res);
        return res;
    }
};
```

使用迭代法：

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while(cur != nullptr || !st.empty())        //cur非空或者栈非空
        {
            if(cur != nullptr)      //如果是cur非空，将cur放入栈中，cur移动到左节点
            {
                st.push(cur);
                cur = cur->left;
            }else{                  //cur为空，说明到达叶子节点，将栈顶弹出，cur移动到右节点
                cur = st.top();
                st.pop();
                res.push_back(cur->val);
                cur = cur->right;
            }
        }

        return res;
    }
};
```

## [最小栈](https://leetcode.cn/problems/min-stack/)

对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。

因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。

那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。

![fig1](https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif)

```c++
class MinStack {
public:
    stack<int> st;
    stack<int> min_st;
    MinStack() {
        min_st.push(INT_MAX);
    }
    
    //取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中
    void push(int val) {
        st.push(val);
        min_st.push(min(min_st.top(),val));     
    }
    
    void pop() {
        st.pop();
        min_st.pop();
    }
    
    int top() {
        return st.top();
    }
    
    int getMin() {
        return min_st.top();
    }
};
```

## [字符串解码](https://leetcode.cn/problems/decode-string/)

```c++
class Solution {
public:
    string decodeString(string s) {
        stack<int> num_stk;//数字栈
        stack<string> str_stk;//字符串栈
        string str;//当前正在累积的字符串
        for(int i=0;i<s.size();++i){
            if(isdigit(s[i])){//遇到数字
                int n=s[i]-'0';
                while(isdigit(s[++i])){//数字可能有多位
                    n=10*n+s[i]-'0';
                }
                num_stk.push(n);//加入数字栈
                --i;//往后退一步(for循环处有自增操作)
            }
            else if(s[i]=='['){//遇到左括号
                str_stk.push(str);//将当前累积的字符串入栈
                str="";//开始记录新的一段字符串
            }
            else if(s[i]==']'){//遇到右括号
                string tmp;
                //将当前字符串按数字栈栈顶元素为倍数进行扩展
                for(int i=0;i<num_stk.top();++i){
                    tmp+=str;
                }
                str=tmp;
                num_stk.pop();//数字栈栈顶元素弹出
                //字符串栈栈顶元素弹出来并与当前字符串拼接，作为新的当前正在累积的字符串
                str=str_stk.top()+str;
                str_stk.pop();
            }
            else{
                str+=s[i];//当前字符串继续累积
            }
        }
        return str;
    }
};
```

## [每日温度](https://leetcode.cn/problems/daily-temperatures/)

我的方法就是暴力求解。两层for循环去找。问题是超大数据会超时。

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int length = temperatures.size();
        vector<int> answer(length,0);  //初始化为0

        for(int i = 0; i< length;i++)  //外循环
        {
            for(int j = i+1;j < length;j++)        //内循环找大值
            {
                if(temperatures[j] > temperatures[i])
                {
                    answer[i] = j-i;
                    break;       //找到一个就退出
                }
            }
        }

        return answer;
    }
};
```

官方题解，单调栈

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int length = temperatures.size();
        vector<int> answer(length);
        stack<int> s;
        for(int i = 0; i < length;i++)
        {
            //如果栈不为空，且当前温度高于栈顶的温度
            while(!s.empty() && temperatures[i] > temperatures[s.top()])
            {
                int previousIndex = s.top();
                answer[previousIndex] = i - previousIndex;      //天数就是下标差
                s.pop();
            }
            s.push(i);  //如果栈为空则直接加入下标
        }
        return answer;
    }
};
```

